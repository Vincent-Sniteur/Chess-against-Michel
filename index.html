<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Échecs contre Michel</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500;600;700&family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #4361ee;
            --primary-light: #4895ef;
            --secondary-color: #3a0ca3;
            --accent-color: #f72585;
            --green-color: #4ade80;
            --green-light: #86efac;
            --danger-color: #f72585;
            --warning-color: #ffa116;
            --background-color: #f8fafc;
            --text-color: #1e293b;
            --border-color: #cbd5e1;
            --card-background: #ffffff;
            --light-square: #f0d9b5;
            --dark-square: #b58863;
            --highlight-square: rgba(255, 255, 100, 0.5);
            --last-move-square: rgba(155, 199, 0, 0.45);
            --available-move: rgba(20, 85, 30, 0.5);
            --check-square: rgba(255, 87, 87, 0.5);
            --shadow-sm: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            --border-radius: 8px;
            --transition-speed: 0.3s;
        }

        [data-theme="dark"] {
            --primary-color: #6366f1;
            --primary-light: #818cf8;
            --secondary-color: #7c3aed;
            --accent-color: #ec4899;
            --green-color: #10b981;
            --green-light: #34d399;
            --danger-color: #f43f5e;
            --warning-color: #fb923c;
            --background-color: #0f172a;
            --text-color: #e2e8f0;
            --border-color: #334155;
            --card-background: #1e293b;
            --light-square: #779556;
            --dark-square: #3b593b;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Montserrat', sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            line-height: 1.6;
            padding: 20px;
            max-width: 1300px;
            margin: 0 auto;
            transition: background-color var(--transition-speed) ease, color var(--transition-speed) ease;
        }

        nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 0;
            margin-bottom: 20px;
        }

        .logo {
            display: flex;
            align-items: center;
            font-weight: 600;
            font-size: 1.6rem;
            color: var(--primary-color);
            text-decoration: none;
        }

        .logo:hover {
            transform: scale(1.03);
        }

        .logo-icon {
            width: 36px;
            height: 36px;
            margin-right: 10px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-6px); }
            100% { transform: translateY(0px); }
        }

        .logo-icon::before {
            content: '♞';
            font-size: 28px;
        }

        .nav-controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .btn {
            padding: 10px 16px;
            border-radius: var(--border-radius);
            border: none;
            font-weight: 500;
            cursor: pointer;
            transition: all var(--transition-speed);
            font-family: 'Montserrat', sans-serif;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            letter-spacing: 0.3px;
            position: relative;
            overflow: hidden;
        }

        .btn::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 5px;
            height: 5px;
            background: rgba(255, 255, 255, 0.4);
            opacity: 0;
            border-radius: 100%;
            transform: scale(1, 1) translate(-50%, -50%);
            transform-origin: 50% 50%;
        }

        .btn:active::after {
            opacity: 1;
            transform: scale(50, 50) translate(-50%, -50%);
            transition: all 0.6s ease-out;
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: white;
            box-shadow: 0 4px 6px rgba(67, 97, 238, 0.15);
        }

        .btn-primary:hover {
            background-color: var(--secondary-color);
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(67, 97, 238, 0.2);
        }

        .btn-outline {
            background-color: transparent;
            color: var(--primary-color);
            border: 1px solid var(--primary-color);
        }

        .btn-outline:hover {
            background-color: var(--primary-color);
            color: white;
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .btn-danger {
            background-color: var(--danger-color);
            color: white;
            box-shadow: 0 4px 6px rgba(247, 37, 133, 0.15);
        }

        .btn-danger:hover {
            background-color: var(--danger-color);
            filter: brightness(1.1);
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(247, 37, 133, 0.2);
        }

        .theme-switch {
            width: 50px;
            height: 26px;
            background-color: var(--border-color);
            border-radius: 13px;
            position: relative;
            cursor: pointer;
            transition: background-color var(--transition-speed);
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }

        .theme-switch::after {
            content: '';
            position: absolute;
            width: 22px;
            height: 22px;
            background-color: white;
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform var(--transition-speed);
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .theme-switch.dark::after {
            transform: translateX(24px);
        }

        .theme-switch.dark {
            background-color: var(--primary-color);
        }

        .theme-switch:hover::after {
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }

        h1, h2, h3, h4 {
            font-family: 'Montserrat', sans-serif;
        }

        h1 {
            color: var(--primary-color);
            text-align: center;
            margin: 30px 0;
            font-weight: 700;
            font-size: 2.5rem;
            background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -0.5px;
        }

        .container {
            background-color: var(--card-background);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-lg);
            padding: 30px;
            margin-bottom: 30px;
            transition: all var(--transition-speed) ease;
            border: 1px solid var(--border-color);
        }

        .game-area {
            display: grid;
            grid-template-columns: minmax(320px, 600px) 1fr;
            gap: 40px;
        }

        @media (max-width: 992px) {
            .game-area {
                grid-template-columns: 1fr;
            }
        }

        .board-container {
            aspect-ratio: 1;
            width: 100%;
            max-width: 600px;
            margin: 0 auto;
            position: relative;
            user-select: none;
            perspective: 1000px;
        }

        .chessboard {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 100%;
            height: 100%;
            border: 5px solid var(--dark-square);
            border-radius: var(--border-radius);
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
            transform-style: preserve-3d;
            transition: transform 0.8s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .flipped {
            transform: rotateX(180deg);
        }

        .square {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            font-size: 3vw; /* Responsive font size */
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
            overflow: hidden;
        }

        .square:hover {
            transform: scale(1.02);
            z-index: 2;
        }

        @media (min-width: 600px) {
            .square {
                font-size: 42px;
            }
        }

        .light {
            background-color: var(--light-square);
        }

        .dark {
            background-color: var(--dark-square);
        }

        .square.highlight {
            background-color: var(--highlight-square);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { background-color: var(--highlight-square); }
            50% { background-color: rgba(255, 255, 100, 0.7); }
            100% { background-color: var(--highlight-square); }
        }

        .square.last-move {
            background-color: var(--last-move-square);
        }

        .square.check {
            background-color: var(--check-square);
            animation: check-pulse 1.5s infinite;
        }

        @keyframes check-pulse {
            0% { background-color: var(--check-square); }
            50% { background-color: rgba(255, 87, 87, 0.7); }
            100% { background-color: var(--check-square); }
        }

        .piece {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: grab;
            z-index: 10;
            transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            backface-visibility: hidden;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .piece:active {
            cursor: grabbing;
        }

        .piece:hover {
            transform: scale(1.15);
        }

        .piece.captured {
            animation: capture 0.5s ease-out;
        }

        @keyframes capture {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(0.1); opacity: 0; }
        }

        .piece.move {
            animation: move 0.3s cubic-bezier(0.215, 0.610, 0.355, 1.000);
        }

        @keyframes move {
            0% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0); }
        }

        .available-move {
            position: absolute;
            width: 30%;
            height: 30%;
            border-radius: 50%;
            background-color: var(--available-move);
            z-index: 5;
            animation: fadeIn 0.3s;
        }

        .capture-move {
            position: absolute;
            width: 90%;
            height: 90%;
            border-radius: 50%;
            border: 4px solid var(--available-move);
            z-index: 5;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.8); }
            to { opacity: 1; transform: scale(1); }
        }

        .board-labels {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .rank-labels, .file-labels {
            position: absolute;
            display: flex;
            justify-content: space-around;
        }

        .rank-labels {
            flex-direction: column-reverse;
            left: -20px;
            top: 10px;
            height: calc(100% - 20px);
        }

        .file-labels {
            bottom: -20px;
            left: 10px;
            width: calc(100% - 20px);
        }

        .rank-label, .file-label {
            font-size: 12px;
            color: var(--text-color);
            opacity: 0.7;
            font-weight: 500;
        }

        .game-info {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .game-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .color-selection {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            width: 100%;
        }

        .color-selection .btn {
            flex: 1;
        }

        .player-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            border-radius: var(--border-radius);
            background-color: rgba(203, 213, 225, 0.1);
            margin-bottom: 10px;
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-sm);
            transition: all var(--transition-speed);
        }

        .player-info:hover {
            box-shadow: var(--shadow-md);
            transform: translateY(-2px);
        }

        .player-name {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 500;
        }

        .player-avatar {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background-color: var(--primary-color);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .michel-avatar {
            background-color: var(--secondary-color);
        }

        .turn-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: var(--green-color);
            margin-left: 10px;
            transition: opacity 0.3s;
        }

        .clock-display {
            margin-left: auto;
            font-family: 'Roboto', monospace;
            font-size: 1.1rem;
            font-weight: 500;
            letter-spacing: 0.5px;
            padding: 4px 10px;
            border-radius: 4px;
            background-color: rgba(203, 213, 225, 0.2);
            transition: all 0.3s;
        }

        .active-clock {
            box-shadow: 0 0 0 2px var(--green-color);
            animation: clock-pulse 2s infinite;
        }

        @keyframes clock-pulse {
            0% { box-shadow: 0 0 0 2px var(--green-color); }
            50% { box-shadow: 0 0 0 2px var(--primary-color); }
            100% { box-shadow: 0 0 0 2px var(--green-color); }
        }

        .captured-pieces {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            font-size: 20px;
            min-height: 30px;
            margin: 10px 0;
            padding: 8px;
            border-radius: var(--border-radius);
            background-color: rgba(203, 213, 225, 0.1);
            border: 1px dashed var(--border-color);
        }

        .captured-piece {
            transition: transform 0.2s;
        }

        .captured-piece:hover {
            transform: scale(1.2);
        }

        .move-history {
            margin-top: 20px;
            overflow-y: auto;
            max-height: 400px;
            padding: 15px;
            border-radius: var(--border-radius);
            background-color: rgba(203, 213, 225, 0.1);
            border: 1px solid var(--border-color);
            box-shadow: var(--shadow-sm);
        }

        .move-history h3 {
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 8px;
        }

        .move-list {
            width: 100%;
            border-collapse: collapse;
        }

        .move-list th, .move-list td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        .move-list th {
            font-weight: 600;
            color: var(--primary-color);
        }

        .move-list tr:hover {
            background-color: rgba(67, 97, 238, 0.05);
        }

        .move-white, .move-black {
            font-family: 'Roboto', monospace;
            letter-spacing: 0.5px;
            transition: all 0.2s;
        }

        .move-white:hover, .move-black:hover {
            color: var(--primary-color);
            font-weight: 500;
        }

        .move-list tr.current-move {
            background-color: rgba(67, 97, 238, 0.1);
        }

        .game-status {
            padding: 15px;
            border-radius: var(--border-radius);
            background-color: var(--card-background);
            margin-top: 20px;
            border-left: 4px solid var(--primary-color);
            box-shadow: var(--shadow-sm);
            transition: all 0.3s;
        }

        .game-status.check {
            border-left-color: var(--warning-color);
            animation: status-pulse 2s infinite;
        }

        .game-status.checkmate, .game-status.stalemate {
            border-left-color: var(--danger-color);
            animation: status-pulse 2s infinite;
        }

        @keyframes status-pulse {
            0% { box-shadow: var(--shadow-sm); }
            50% { box-shadow: 0 0 10px rgba(247, 37, 133, 0.3); }
            100% { box-shadow: var(--shadow-sm); }
        }

        .thinking {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
            opacity: 0;
            transition: opacity 0.3s;
            padding: 10px;
            border-radius: var(--border-radius);
            background-color: rgba(203, 213, 225, 0.1);
        }

        .thinking.active {
            opacity: 1;
        }

        .thinking-text {
            animation: thinking-text 2s infinite;
        }

        @keyframes thinking-text {
            0% { color: var(--primary-color); }
            50% { color: var(--secondary-color); }
            100% { color: var(--primary-color); }
        }

        .thinking-dots {
            display: flex;
            gap: 3px;
        }

        .thinking-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: var(--primary-color);
            animation: thinking 1.4s infinite ease-in-out both;
        }

        .thinking-dot:nth-child(1) {
            animation-delay: -0.32s;
        }

        .thinking-dot:nth-child(2) {
            animation-delay: -0.16s;
        }

        @keyframes thinking {
            0%, 80%, 100% { 
                transform: scale(0);
            } 
            40% { 
                transform: scale(1.0);
            }
        }

        .difficulty-selector {
            display: flex;
            justify-content: space-between;
            gap: 10px;
            margin: 20px 0;
        }

        .difficulty-option {
            padding: 10px;
            border-radius: var(--border-radius);
            border: 1px solid var(--border-color);
            cursor: pointer;
            flex: 1;
            text-align: center;
            transition: all 0.2s;
            font-weight: 500;
        }

        .difficulty-option:hover {
            background-color: rgba(67, 97, 238, 0.1);
            transform: translateY(-2px);
            box-shadow: var(--shadow-sm);
        }

        .difficulty-option.selected {
            background-color: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
            box-shadow: 0 2px 5px rgba(67, 97, 238, 0.3);
        }

        .toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
        }

        .toast {
            background-color: var(--card-background);
            color: var(--text-color);
            padding: 15px 20px;
            border-radius: var(--border-radius);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            border-left: 4px solid var(--primary-color);
            transform: translateX(120%);
            animation: slideIn 0.5s forwards, fadeOut 0.5s forwards 4.5s;
            max-width: 300px;
            font-weight: 500;
        }

        .toast.toast-danger {
            border-left-color: var(--danger-color);
        }

        .toast.toast-warning {
            border-left-color: var(--warning-color);
        }

        .toast.toast-success {
            border-left-color: var(--green-color);
        }

        @keyframes slideIn {
            to { transform: translateX(0); }
        }

        @keyframes fadeOut {
            to { opacity: 0; }
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(2px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all var(--transition-speed) ease;
        }

        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background-color: var(--card-background);
            border-radius: var(--border-radius);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            width: 90%;
            max-width: 500px;
            padding: 30px;
            transform: translateY(-20px) scale(0.95);
            transition: transform var(--transition-speed) ease;
            border: 1px solid var(--border-color);
        }

        .modal-overlay.show .modal {
            transform: translateY(0) scale(1);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 15px;
        }

        .modal-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--primary-color);
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--text-color);
            transition: color 0.2s;
        }

        .modal-close:hover {
            color: var(--danger-color);
        }

        .modal-body {
            margin-bottom: 20px;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            padding-top: 15px;
            border-top: 1px solid var(--border-color);
        }

        /* Promotion modal */
        .promotion-pieces {
            display: flex;
            justify-content: space-around;
            margin: 20px 0;
        }

        .promotion-piece {
            font-size: 48px;
            cursor: pointer;
            padding: 15px;
            border-radius: var(--border-radius);
            transition: all 0.2s;
        }

        .promotion-piece:hover {
            background-color: rgba(67, 97, 238, 0.1);
            transform: scale(1.1) translateY(-5px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        footer {
            text-align: center;
            margin-top: 50px;
            padding: 30px 0;
            color: var(--text-color);
            opacity: 0.8;
            font-size: 0.95rem;
            border-top: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        footer a {
            color: var(--primary-color);
            text-decoration: none;
            transition: all 0.2s;
        }

        footer a:hover {
            color: var(--secondary-color);
            text-decoration: underline;
        }

        .coffee-button {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background-color: #ffdd00;
            color: #000000;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: 600;
            text-decoration: none;
            margin-top: 10px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            transition: all 0.2s;
        }

        .coffee-button:hover {
            transform: translateY(-2px) scale(1.03);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
            text-decoration: none !important;
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .container {
                padding: 15px;
            }
            
            h1 {
                font-size: 1.8rem;
            }
            
            .game-controls {
                flex-direction: column;
            }

            .player-info {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }

            .clock-display {
                margin-left: 0;
                width: 100%;
                text-align: center;
            }
        }

        .loading-bar {
            position: fixed;
            top: 0;
            left: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--primary-color), var(--secondary-color));
            width: 0%;
            z-index: 1001;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="loading-bar" id="loading-bar"></div>
    
    <nav>
        <a href="#" class="logo">
            <div class="logo-icon"></div>
            Échecs contre Michel
        </a>
        <div class="nav-controls">
            <div class="theme-switch" id="theme-switch" title="Changer de thème"></div>
            <button class="btn btn-outline" id="hint-btn">Conseil</button>
            <button class="btn btn-danger" id="reset-btn">Nouvelle partie</button>
        </div>
    </nav>

    <div class="container">
        <div class="game-area">
            <div class="board-area">
                <div class="color-selection">
                    <button class="btn btn-primary" id="play-white">Jouer les blancs</button>
                    <button class="btn btn-outline" id="play-black">Jouer les noirs</button>
                </div>
                
                <div class="board-container">
                    <div class="chessboard" id="chessboard">
                        <!-- Chess squares will be generated here -->
                    </div>
                    <div class="board-labels">
                        <div class="rank-labels">
                            <div class="rank-label">8</div>
                            <div class="rank-label">7</div>
                            <div class="rank-label">6</div>
                            <div class="rank-label">5</div>
                            <div class="rank-label">4</div>
                            <div class="rank-label">3</div>
                            <div class="rank-label">2</div>
                            <div class="rank-label">1</div>
                        </div>
                        <div class="file-labels">
                            <div class="file-label">a</div>
                            <div class="file-label">b</div>
                            <div class="file-label">c</div>
                            <div class="file-label">d</div>
                            <div class="file-label">e</div>
                            <div class="file-label">f</div>
                            <div class="file-label">g</div>
                            <div class="file-label">h</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="game-info">
                <div class="game-controls">
                    <button class="btn btn-primary" id="undo-btn">Annuler le coup</button>
                    <button class="btn btn-outline" id="flip-btn">Retourner l'échiquier</button>
                </div>
                
                <div class="difficulty-selector">
                    <div class="difficulty-option" data-level="1">Facile</div>
                    <div class="difficulty-option selected" data-level="2">Moyen</div>
                    <div class="difficulty-option" data-level="3">Difficile</div>
                </div>
                
                <div class="player-panel">
                    <div class="player-info">
                        <div class="player-name">
                            <div class="player-avatar michel-avatar">M</div>
                            <span>Michel (Robot)</span>
                            <div class="turn-indicator" id="michel-turn"></div>
                        </div>
                        <div class="clock-display" id="michel-clock">00:00</div>
                    </div>
                    <div class="captured-pieces" id="captured-by-user"></div>
                </div>
                
                <div class="game-status" id="game-status">
                    En attente du début de la partie...
                </div>
                
                <div class="thinking" id="thinking-indicator">
                    <span class="thinking-text">Michel réfléchit</span>
                    <div class="thinking-dots">
                        <div class="thinking-dot"></div>
                        <div class="thinking-dot"></div>
                        <div class="thinking-dot"></div>
                    </div>
                </div>
                
                <div class="player-panel">
                    <div class="captured-pieces" id="captured-by-michel"></div>
                    <div class="player-info">
                        <div class="player-name">
                            <div class="player-avatar">U</div>
                            <span>Utilisateur</span>
                            <div class="turn-indicator" id="user-turn"></div>
                        </div>
                        <div class="clock-display" id="user-clock">00:00</div>
                    </div>
                </div>
                
                <div class="move-history">
                    <h3>
                        Historique des coups
                        <button class="btn btn-outline" id="copy-pgn" style="padding: 2px 8px; font-size: 0.8rem;">Copier PGN</button>
                    </h3>
                    <table class="move-list" id="move-list">
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Blancs</th>
                                <th>Noirs</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Move history will be added here -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Promotion modal -->
    <div class="modal-overlay" id="promotion-modal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">Promotion du pion</h3>
            </div>
            <div class="modal-body">
                <p>Choisissez une pièce pour promouvoir votre pion :</p>
                <div class="promotion-pieces" id="promotion-pieces">
                    <!-- Promotion pieces will be added here -->
                </div>
            </div>
        </div>
    </div>
    
    <!-- New game modal -->
    <div class="modal-overlay" id="new-game-modal">
        <div class="modal">
            <div class="modal-header">
                <h3 class="modal-title">Nouvelle partie</h3>
                <button class="modal-close">&times;</button>
            </div>
            <div class="modal-body">
                <p>Voulez-vous commencer une nouvelle partie ?</p>
            </div>
            <div class="modal-footer">
                <button class="btn btn-outline" id="cancel-new-game">Annuler</button>
                <button class="btn btn-primary" id="confirm-new-game">Nouvelle partie</button>
            </div>
        </div>
    </div>

    <!-- Toast container -->
    <div class="toast-container" id="toast-container">
        <!-- Toasts will be added here -->
    </div>

    <footer>
        <p>Fait avec ❤️ par Infenium / Sniteur</p>
        <p>Version 0.3</p>
        <a href="https://buymeacoffee.com/sniteur" target="_blank" class="coffee-button">
            ☕ M'offrir un café
        </a>
        <p>Échecs contre Michel - Un jeu d'échecs simple contre un robot</p>
    </footer>

    <script>
        // Theme switcher
        const themeSwitch = document.getElementById('theme-switch');
        const body = document.body;
        
        // Check for saved theme preference or default to light
        const savedTheme = localStorage.getItem('theme') || 'light';
        if (savedTheme === 'dark') {
            body.setAttribute('data-theme', 'dark');
            themeSwitch.classList.add('dark');
        }
        
        themeSwitch.addEventListener('click', () => {
            if (body.getAttribute('data-theme') === 'dark') {
                body.removeAttribute('data-theme');
                localStorage.setItem('theme', 'light');
                themeSwitch.classList.remove('dark');
                showToast('Thème clair activé');
            } else {
                body.setAttribute('data-theme', 'dark');
                localStorage.setItem('theme', 'dark');
                themeSwitch.classList.add('dark');
                showToast('Thème sombre activé');
            }
        });

        // Loading bar animation
        function showLoading() {
            const loadingBar = document.getElementById('loading-bar');
            loadingBar.style.width = '0%';
            
            let width = 0;
            const loadingInterval = setInterval(() => {
                if (width >= 100) {
                    clearInterval(loadingInterval);
                    setTimeout(() => {
                        loadingBar.style.width = '0%';
                    }, 300);
                } else {
                    width += 5;
                    loadingBar.style.width = width + '%';
                }
            }, 20);
        }

        // Show toast notification
        function showToast(message, type = '') {
            const toast = document.createElement('div');
            toast.className = 'toast ' + type;
            toast.textContent = message;
            
            const container = document.getElementById('toast-container');
            container.appendChild(toast);
            
            // Remove toast after animation
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.remove();
                }
            }, 5000);
        }
        
        // Show modal
        function showModal(modalId) {
            document.getElementById(modalId).classList.add('show');
        }
        
        // Hide modal
        function hideModal(modalId) {
            document.getElementById(modalId).classList.remove('show');
        }
        
        // Show thinking indicator
        function showThinking() {
            document.getElementById('thinking-indicator').classList.add('active');
        }
        
        // Hide thinking indicator
        function hideThinking() {
            document.getElementById('thinking-indicator').classList.remove('active');
        }

        // Chess game state and logic
        const PIECES = {
            WHITE_KING: '♔',
            WHITE_QUEEN: '♕',
            WHITE_ROOK: '♖',
            WHITE_BISHOP: '♗',
            WHITE_KNIGHT: '♘',
            WHITE_PAWN: '♙',
            BLACK_KING: '♚',
            BLACK_QUEEN: '♛',
            BLACK_ROOK: '♜',
            BLACK_BISHOP: '♝',
            BLACK_KNIGHT: '♞',
            BLACK_PAWN: '♟'
        };
        
        const FILES = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
        const RANKS = ['1', '2', '3', '4', '5', '6', '7', '8'];
        
        // Game state variables
        let board = [];
        let currentPlayer = 'white'; // 'white' or 'black'
        let userColor = 'white'; // Default user color
        let selectedPiece = null;
        let moveHistory = [];
        let capturedPieces = {
            white: [], // Pieces captured by white
            black: []  // Pieces captured by black
        };
        let boardFlipped = false;
        let gameStatus = 'active'; // 'active', 'check', 'checkmate', 'stalemate'
        let difficultyLevel = 2; // 1=easy, 2=medium, 3=hard
        
        // Chess clocks
        let whiteTime = 0; // in seconds
        let blackTime = 0; // in seconds
        let clockInterval = null;
        let clockStartTime = null;
        
        // Castling rights
        let castlingRights = {
            whiteKingSide: true,
            whiteQueenSide: true,
            blackKingSide: true,
            blackQueenSide: true
        };
        
        // Kings positions for check detection
        let kingPositions = {
            white: { x: 4, y: 0 }, // e1
            black: { x: 4, y: 7 }  // e8
        };
        
        // En passant target square
        let enPassantTarget = null;
        
        // Promotion variables
        let pendingPromotion = null;
        
        // Format time for display
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }
        
        // Start the clock for the current player
        function startClock() {
            if (clockInterval) {
                clearInterval(clockInterval);
            }
            
            clockStartTime = Date.now();
            
            clockInterval = setInterval(() => {
                const elapsedTime = Math.floor((Date.now() - clockStartTime) / 1000);
                
                if (currentPlayer === 'white') {
                    whiteTime += 1;
                    document.getElementById(userColor === 'white' ? 'user-clock' : 'michel-clock').textContent = formatTime(whiteTime);
                    document.getElementById(userColor === 'white' ? 'user-clock' : 'michel-clock').classList.add('active-clock');
                    document.getElementById(userColor === 'white' ? 'michel-clock' : 'user-clock').classList.remove('active-clock');
                } else {
                    blackTime += 1;
                    document.getElementById(userColor === 'black' ? 'user-clock' : 'michel-clock').textContent = formatTime(blackTime);
                    document.getElementById(userColor === 'black' ? 'user-clock' : 'michel-clock').classList.add('active-clock');
                    document.getElementById(userColor === 'black' ? 'michel-clock' : 'user-clock').classList.remove('active-clock');
                }
            }, 1000);
        }
        
        // Stop the clock
        function stopClock() {
            if (clockInterval) {
                clearInterval(clockInterval);
                clockInterval = null;
            }
        }
        
        // Reset the clocks
        function resetClocks() {
            stopClock();
            whiteTime = 0;
            blackTime = 0;
            document.getElementById('user-clock').textContent = '00:00';
            document.getElementById('michel-clock').textContent = '00:00';
            document.getElementById('user-clock').classList.remove('active-clock');
            document.getElementById('michel-clock').classList.remove('active-clock');
        }
        
        // Initialize the chessboard
        function initializeBoard() {
            showLoading();
            const chessboard = document.getElementById('chessboard');
            chessboard.innerHTML = ''; // Clear board
            
            board = [];
            
            // Create the board array (8x8)
            for (let y = 0; y < 8; y++) {
                const row = [];
                for (let x = 0; x < 8; x++) {
                    row.push(null); // Empty square
                }
                board.push(row);
            }
            
            // Place pieces
            // Pawns
            for (let x = 0; x < 8; x++) {
                board[1][x] = { type: 'pawn', color: 'white' };
                board[6][x] = { type: 'pawn', color: 'black' };
            }
            
            // Rooks
            board[0][0] = { type: 'rook', color: 'white' };
            board[0][7] = { type: 'rook', color: 'white' };
            board[7][0] = { type: 'rook', color: 'black' };
            board[7][7] = { type: 'rook', color: 'black' };
            
            // Knights
            board[0][1] = { type: 'knight', color: 'white' };
            board[0][6] = { type: 'knight', color: 'white' };
            board[7][1] = { type: 'knight', color: 'black' };
            board[7][6] = { type: 'knight', color: 'black' };
            
            // Bishops
            board[0][2] = { type: 'bishop', color: 'white' };
            board[0][5] = { type: 'bishop', color: 'white' };
            board[7][2] = { type: 'bishop', color: 'black' };
            board[7][5] = { type: 'bishop', color: 'black' };
            
            // Queens
            board[0][3] = { type: 'queen', color: 'white' };
            board[7][3] = { type: 'queen', color: 'black' };
            
            // Kings
            board[0][4] = { type: 'king', color: 'white' };
            board[7][4] = { type: 'king', color: 'black' };
            
            // Reset king positions
            kingPositions = {
                white: { x: 4, y: 0 }, // e1
                black: { x: 4, y: 7 }  // e8
            };
            
            // Reset castling rights
            castlingRights = {
                whiteKingSide: true,
                whiteQueenSide: true,
                blackKingSide: true,
                blackQueenSide: true
            };
            
            // Reset en passant
            enPassantTarget = null;
            
            // Set board orientation based on user color
            boardFlipped = (userColor === 'black');
            if (boardFlipped) {
                chessboard.classList.add('flipped');
            } else {
                chessboard.classList.remove('flipped');
            }
            
            // Create visual board
            renderBoard();
            
            // Reset move history
            moveHistory = [];
            updateMoveHistory();
            
            // Reset captured pieces
            capturedPieces = { white: [], black: [] };
            updateCapturedPieces();
            
            // Reset game status
            gameStatus = 'active';
            updateGameStatus();
            
            // Reset current player to white
            currentPlayer = 'white';
            
            // Update turn indicators
            updateTurnIndicators();
            
            // Reset clocks
            resetClocks();
            startClock();
            
            // If user is playing black, let AI make the first move
            if (userColor === 'black') {
                showThinking();
                setTimeout(() => {
                    makeAIMove();
                    hideThinking();
                }, 1000);
            }
        }
        
        // Render the chessboard
        function renderBoard() {
            const chessboard = document.getElementById('chessboard');
            chessboard.innerHTML = ''; // Clear board
            
            for (let y = 7; y >= 0; y--) {
                for (let x = 0; x < 8; x++) {
                    // Adjust coordinates if board is flipped
                    let displayX = boardFlipped ? 7 - x : x;
                    let displayY = boardFlipped ? 7 - y : y;
                    
                    const square = document.createElement('div');
                    square.className = 'square';
                    square.classList.add((displayX + displayY) % 2 === 0 ? 'light' : 'dark');
                    square.dataset.x = x;
                    square.dataset.y = y;
                    
                    // Coordinate notation
                    const coord = FILES[x] + RANKS[y];
                    square.dataset.coord = coord;
                    
                    // Add piece if exists
                    const piece = board[y][x];
                    if (piece) {
                        const pieceElement = document.createElement('div');
                        pieceElement.className = 'piece';
                        pieceElement.dataset.type = piece.type;
                        pieceElement.dataset.color = piece.color;
                        
                        // Set the unicode character
                        pieceElement.textContent = getPieceSymbol(piece);
                        
                        square.appendChild(pieceElement);
                    }
                    
                    // Add square to board
                    chessboard.appendChild(square);
                    
                    // Add event listeners
                    square.addEventListener('click', handleSquareClick);
                }
            }
            
            // Add last move highlighting
            if (moveHistory.length > 0) {
                const lastMove = moveHistory[moveHistory.length - 1];
                highlightLastMove(lastMove.from, lastMove.to);
            }
        }
        
        // Highlight the last move made
        function highlightLastMove(from, to) {
            // Convert algebraic notation to coordinates
            const fromFile = FILES.indexOf(from[0]);
            const fromRank = parseInt(from[1]) - 1;
            const toFile = FILES.indexOf(to[0]);
            const toRank = parseInt(to[1]) - 1;
            
            // Highlight the squares
            const fromSquare = document.querySelector(`.square[data-x="${fromFile}"][data-y="${fromRank}"]`);
            const toSquare = document.querySelector(`.square[data-x="${toFile}"][data-y="${toRank}"]`);
            
            if (fromSquare) fromSquare.classList.add('last-move');
            if (toSquare) toSquare.classList.add('last-move');
        }
        
        // Get the Unicode symbol for a piece
        function getPieceSymbol(piece) {
            if (!piece) return '';
            
            const { color, type } = piece;
            
            if (color === 'white') {
                switch (type) {
                    case 'king': return PIECES.WHITE_KING;
                    case 'queen': return PIECES.WHITE_QUEEN;
                    case 'rook': return PIECES.WHITE_ROOK;
                    case 'bishop': return PIECES.WHITE_BISHOP;
                    case 'knight': return PIECES.WHITE_KNIGHT;
                    case 'pawn': return PIECES.WHITE_PAWN;
                }
            } else {
                switch (type) {
                    case 'king': return PIECES.BLACK_KING;
                    case 'queen': return PIECES.BLACK_QUEEN;
                    case 'rook': return PIECES.BLACK_ROOK;
                    case 'bishop': return PIECES.BLACK_BISHOP;
                    case 'knight': return PIECES.BLACK_KNIGHT;
                    case 'pawn': return PIECES.BLACK_PAWN;
                }
            }
            
            return '';
        }
        
        // Handle square click
        function handleSquareClick(event) {
            // If game is over, don't allow moves
            if (gameStatus === 'checkmate' || gameStatus === 'stalemate') {
                return;
            }
            
            // If it's not the user's turn, don't allow moves
            if (currentPlayer !== userColor) {
                showToast("C'est le tour de Michel, veuillez patienter...", 'toast-warning');
                return;
            }
            
            const square = event.currentTarget;
            const x = parseInt(square.dataset.x);
            const y = parseInt(square.dataset.y);
            
            // Get the piece at the clicked square
            const piece = board[y][x];
            
            // If no piece is selected and there's a piece belonging to the current player
            if (!selectedPiece && piece && piece.color === currentPlayer) {
                selectPiece(x, y);
                return;
            }
            
            // If a piece is already selected
            if (selectedPiece) {
                // If the clicked square is the same as the selected piece, deselect it
                if (selectedPiece.x === x && selectedPiece.y === y) {
                    deselectPiece();
                    return;
                }
                
                // If the clicked square has a piece of the same color, select that piece instead
                if (piece && piece.color === currentPlayer) {
                    deselectPiece();
                    selectPiece(x, y);
                    return;
                }
                
                // Try to move the selected piece to the clicked square
                const validMoves = getValidMoves(selectedPiece.x, selectedPiece.y);
                const targetMove = validMoves.find(move => move.x === x && move.y === y);
                
                if (targetMove) {
                    // Add move animation
                    const pieceElement = document.querySelector(`.square[data-x="${selectedPiece.x}"][data-y="${selectedPiece.y}"] .piece`);
                    pieceElement.classList.add('move');
                    
                    // If there's a piece at the target square, add capture animation
                    if (board[y][x]) {
                        const capturedPieceElement = document.querySelector(`.square[data-x="${x}"][data-y="${y}"] .piece`);
                        capturedPieceElement.classList.add('captured');
                    }
                    
                    // Wait for animation to complete
                    setTimeout(() => {
                        // Make the move on the board
                        makeMove(selectedPiece.x, selectedPiece.y, x, y, targetMove.special);
                        deselectPiece();
                        
                        // If there's no pending promotion, let the AI play
                        if (!pendingPromotion) {
                            showThinking();
                            setTimeout(() => {
                                makeAIMove();
                                hideThinking();
                            }, 1000);
                        }
                    }, 300);
                } else {
                    // Invalid move
                    deselectPiece();
                }
            }
        }
        
        // Select a piece
        function selectPiece(x, y) {
            // Highlight the selected piece's square
            const square = document.querySelector(`.square[data-x="${x}"][data-y="${y}"]`);
            square.classList.add('highlight');
            
            selectedPiece = { x, y };
            
            // Show valid moves
            const validMoves = getValidMoves(x, y);
            
            validMoves.forEach(move => {
                const targetSquare = document.querySelector(`.square[data-x="${move.x}"][data-y="${move.y}"]`);
                
                // If it's a capture move
                if (board[move.y][move.x]) {
                    const captureIndicator = document.createElement('div');
                    captureIndicator.className = 'capture-move';
                    targetSquare.appendChild(captureIndicator);
                } else {
                    // Regular move
                    const moveIndicator = document.createElement('div');
                    moveIndicator.className = 'available-move';
                    targetSquare.appendChild(moveIndicator);
                }
            });
        }
        
        // Deselect the currently selected piece
        function deselectPiece() {
            if (!selectedPiece) return;
            
            // Remove highlight from the selected piece's square
            const square = document.querySelector(`.square[data-x="${selectedPiece.x}"][data-y="${selectedPiece.y}"]`);
            square.classList.remove('highlight');
            
            // Remove valid move indicators
            document.querySelectorAll('.available-move, .capture-move').forEach(indicator => {
                indicator.remove();
            });
            
            selectedPiece = null;
        }
        
        // Get valid moves for a piece
        function getValidMoves(x, y) {
            const piece = board[y][x];
            if (!piece) return [];
            
            let moves = [];
            
            switch (piece.type) {
                case 'pawn':
                    moves = getPawnMoves(x, y);
                    break;
                case 'knight':
                    moves = getKnightMoves(x, y);
                    break;
                case 'bishop':
                    moves = getBishopMoves(x, y);
                    break;
                case 'rook':
                    moves = getRookMoves(x, y);
                    break;
                case 'queen':
                    moves = getQueenMoves(x, y);
                    break;
                case 'king':
                    moves = getKingMoves(x, y);
                    break;
            }
            
            // Filter out moves that would leave the king in check
            return moves.filter(move => {
                return !wouldBeInCheck(x, y, move.x, move.y, piece.color);
            });
        }
        
        // Check if a move would leave the king in check
        function wouldBeInCheck(fromX, fromY, toX, toY, color) {
            // Make a deep copy of the board
            const tempBoard = JSON.parse(JSON.stringify(board));
            
            // Temporarily make the move on the copy
            const movingPiece = tempBoard[fromY][fromX];
            tempBoard[toY][toX] = movingPiece;
            tempBoard[fromY][fromX] = null;
            
            // If moving a king, update its position for check detection
            let kingX, kingY;
            if (movingPiece.type === 'king') {
                kingX = toX;
                kingY = toY;
            } else {
                kingX = kingPositions[color].x;
                kingY = kingPositions[color].y;
            }
            
            // Check if the king would be in check
            return isSquareAttacked(kingX, kingY, color === 'white' ? 'black' : 'white', tempBoard);
        }
        
        // Check if a square is under attack by a specific color
        function isSquareAttacked(x, y, attackingColor, checkBoard = board) {
            // Check for pawn attacks
            const pawnDirection = attackingColor === 'white' ? 1 : -1;
            
            // Left diagonal pawn attack
            if (x > 0 && y + pawnDirection >= 0 && y + pawnDirection < 8) {
                const pawn = checkBoard[y + pawnDirection][x - 1];
                if (pawn && pawn.type === 'pawn' && pawn.color === attackingColor) {
                    return true;
                }
            }
            
            // Right diagonal pawn attack
            if (x < 7 && y + pawnDirection >= 0 && y + pawnDirection < 8) {
                const pawn = checkBoard[y + pawnDirection][x + 1];
                if (pawn && pawn.type === 'pawn' && pawn.color === attackingColor) {
                    return true;
                }
            }
            
            // Check for knight attacks
            const knightMoves = [
                { x: x + 2, y: y + 1 }, { x: x + 2, y: y - 1 },
                { x: x - 2, y: y + 1 }, { x: x - 2, y: y - 1 },
                { x: x + 1, y: y + 2 }, { x: x + 1, y: y - 2 },
                { x: x - 1, y: y + 2 }, { x: x - 1, y: y - 2 }
            ];
            
            for (const move of knightMoves) {
                if (move.x >= 0 && move.x < 8 && move.y >= 0 && move.y < 8) {
                    const piece = checkBoard[move.y][move.x];
                    if (piece && piece.type === 'knight' && piece.color === attackingColor) {
                        return true;
                    }
                }
            }
            
            // Check for king attacks (adjacent squares)
            const kingMoves = [
                { x: x + 1, y: y }, { x: x - 1, y: y },
                { x: x, y: y + 1 }, { x: x, y: y - 1 },
                { x: x + 1, y: y + 1 }, { x: x + 1, y: y - 1 },
                { x: x - 1, y: y + 1 }, { x: x - 1, y: y - 1 }
            ];
            
            for (const move of kingMoves) {
                if (move.x >= 0 && move.x < 8 && move.y >= 0 && move.y < 8) {
                    const piece = checkBoard[move.y][move.x];
                    if (piece && piece.type === 'king' && piece.color === attackingColor) {
                        return true;
                    }
                }
            }
            
            // Check for sliding piece attacks (rook, bishop, queen)
            const directions = [
                { dx: 0, dy: 1 },   // up
                { dx: 0, dy: -1 },  // down
                { dx: 1, dy: 0 },   // right
                { dx: -1, dy: 0 },  // left
                { dx: 1, dy: 1 },   // up-right
                { dx: 1, dy: -1 },  // down-right
                { dx: -1, dy: 1 },  // up-left
                { dx: -1, dy: -1 }  // down-left
            ];
            
            for (const dir of directions) {
                let newX = x + dir.dx;
                let newY = y + dir.dy;
                
                while (newX >= 0 && newX < 8 && newY >= 0 && newY < 8) {
                    const piece = checkBoard[newY][newX];
                    
                    if (piece) {
                        if (piece.color === attackingColor) {
                            // Rook can attack along rank and file
                            if (piece.type === 'rook' && (dir.dx === 0 || dir.dy === 0)) {
                                return true;
                            }
                            
                            // Bishop can attack along diagonals
                            if (piece.type === 'bishop' && dir.dx !== 0 && dir.dy !== 0) {
                                return true;
                            }
                            
                            // Queen can attack in any direction
                            if (piece.type === 'queen') {
                                return true;
                            }
                        }
                        
                        // Stop checking this direction if we hit any piece
                        break;
                    }
                    
                    newX += dir.dx;
                    newY += dir.dy;
                }
            }
            
            return false;
        }
        
        // Get valid moves for a pawn
        function getPawnMoves(x, y) {
            const piece = board[y][x];
            const moves = [];
            
            if (piece.color === 'white') {
                // Forward move
                if (y + 1 < 8 && !board[y + 1][x]) {
                    moves.push({ x, y: y + 1 });
                    
                    // Double forward from starting position
                    if (y === 1 && !board[y + 2][x]) {
                        moves.push({ x, y: y + 2, special: 'double-push' });
                    }
                }
                
                // Captures
                if (y + 1 < 8) {
                    // Left diagonal capture
                    if (x - 1 >= 0) {
                        const target = board[y + 1][x - 1];
                        if (target && target.color === 'black') {
                            moves.push({ x: x - 1, y: y + 1 });
                        }
                    }
                    
                    // Right diagonal capture
                    if (x + 1 < 8) {
                        const target = board[y + 1][x + 1];
                        if (target && target.color === 'black') {
                            moves.push({ x: x + 1, y: y + 1 });
                        }
                    }
                }
                
                // En passant capture
                if (y === 4 && enPassantTarget) {
                    if (enPassantTarget.x === x - 1 && enPassantTarget.y === y) {
                        moves.push({ x: x - 1, y: y + 1, special: 'en-passant' });
                    }
                    if (enPassantTarget.x === x + 1 && enPassantTarget.y === y) {
                        moves.push({ x: x + 1, y: y + 1, special: 'en-passant' });
                    }
                }
                
                // Promotion
                if (y === 6) {
                    // Filter and add promotion moves separately
                    moves.forEach(move => {
                        if (move.y === 7) {
                            move.special = 'promotion';
                        }
                    });
                }
            } else { // Black pawn
                // Forward move
                if (y - 1 >= 0 && !board[y - 1][x]) {
                    moves.push({ x, y: y - 1 });
                    
                    // Double forward from starting position
                    if (y === 6 && !board[y - 2][x]) {
                        moves.push({ x, y: y - 2, special: 'double-push' });
                    }
                }
                
                // Captures
                if (y - 1 >= 0) {
                    // Left diagonal capture
                    if (x - 1 >= 0) {
                        const target = board[y - 1][x - 1];
                        if (target && target.color === 'white') {
                            moves.push({ x: x - 1, y: y - 1 });
                        }
                    }
                    
                    // Right diagonal capture
                    if (x + 1 < 8) {
                        const target = board[y - 1][x + 1];
                        if (target && target.color === 'white') {
                            moves.push({ x: x + 1, y: y - 1 });
                        }
                    }
                }
                
                // En passant capture
                if (y === 3 && enPassantTarget) {
                    if (enPassantTarget.x === x - 1 && enPassantTarget.y === y) {
                        moves.push({ x: x - 1, y: y - 1, special: 'en-passant' });
                    }
                    if (enPassantTarget.x === x + 1 && enPassantTarget.y === y) {
                        moves.push({ x: x + 1, y: y - 1, special: 'en-passant' });
                    }
                }
                
                // Promotion
                if (y === 1) {
                    // Filter and add promotion moves separately
                    moves.forEach(move => {
                        if (move.y === 0) {
                            move.special = 'promotion';
                        }
                    });
                }
            }
            
            return moves;
        }
        
        // Get valid moves for a knight
        function getKnightMoves(x, y) {
            const piece = board[y][x];
            const moves = [];
            
            const offsets = [
                { dx: 2, dy: 1 }, { dx: 2, dy: -1 },
                { dx: -2, dy: 1 }, { dx: -2, dy: -1 },
                { dx: 1, dy: 2 }, { dx: 1, dy: -2 },
                { dx: -1, dy: 2 }, { dx: -1, dy: -2 }
            ];
            
            for (const offset of offsets) {
                const newX = x + offset.dx;
                const newY = y + offset.dy;
                
                // Check if the new position is within the board
                if (newX >= 0 && newX < 8 && newY >= 0 && newY < 8) {
                    const targetPiece = board[newY][newX];
                    
                    // Empty square or capture
                    if (!targetPiece || targetPiece.color !== piece.color) {
                        moves.push({ x: newX, y: newY });
                    }
                }
            }
            
            return moves;
        }
        
        // Get valid moves for a bishop
        function getBishopMoves(x, y) {
            const piece = board[y][x];
            const moves = [];
            
            // Diagonal directions
            const directions = [
                { dx: 1, dy: 1 },   // up-right
                { dx: 1, dy: -1 },  // down-right
                { dx: -1, dy: 1 },  // up-left
                { dx: -1, dy: -1 }  // down-left
            ];
            
            for (const dir of directions) {
                let newX = x + dir.dx;
                let newY = y + dir.dy;
                
                while (newX >= 0 && newX < 8 && newY >= 0 && newY < 8) {
                    const targetPiece = board[newY][newX];
                    
                    if (!targetPiece) {
                        // Empty square
                        moves.push({ x: newX, y: newY });
                    } else {
                        // Capture
                        if (targetPiece.color !== piece.color) {
                            moves.push({ x: newX, y: newY });
                        }
                        
                        // Stop when we hit any piece
                        break;
                    }
                    
                    newX += dir.dx;
                    newY += dir.dy;
                }
            }
            
            return moves;
        }
        
        // Get valid moves for a rook
        function getRookMoves(x, y) {
            const piece = board[y][x];
            const moves = [];
            
            // Horizontal and vertical directions
            const directions = [
                { dx: 0, dy: 1 },   // up
                { dx: 0, dy: -1 },  // down
                { dx: 1, dy: 0 },   // right
                { dx: -1, dy: 0 }   // left
            ];
            
            for (const dir of directions) {
                let newX = x + dir.dx;
                let newY = y + dir.dy;
                
                while (newX >= 0 && newX < 8 && newY >= 0 && newY < 8) {
                    const targetPiece = board[newY][newX];
                    
                    if (!targetPiece) {
                        // Empty square
                        moves.push({ x: newX, y: newY });
                    } else {
                        // Capture
                        if (targetPiece.color !== piece.color) {
                            moves.push({ x: newX, y: newY });
                        }
                        
                        // Stop when we hit any piece
                        break;
                    }
                    
                    newX += dir.dx;
                    newY += dir.dy;
                }
            }
            
            return moves;
        }
        
        // Get valid moves for a queen
        function getQueenMoves(x, y) {
            // Queen combines rook and bishop moves
            return [...getRookMoves(x, y), ...getBishopMoves(x, y)];
        }
        
        // Get valid moves for a king
        function getKingMoves(x, y) {
            const piece = board[y][x];
            const moves = [];
            
            // All 8 directions
            const directions = [
                { dx: 0, dy: 1 },    // up
                { dx: 0, dy: -1 },   // down
                { dx: 1, dy: 0 },    // right
                { dx: -1, dy: 0 },   // left
                { dx: 1, dy: 1 },    // up-right
                { dx: 1, dy: -1 },   // down-right
                { dx: -1, dy: 1 },   // up-left
                { dx: -1, dy: -1 }   // down-left
            ];
            
            for (const dir of directions) {
                const newX = x + dir.dx;
                const newY = y + dir.dy;
                
                // Check if the new position is within the board
                if (newX >= 0 && newX < 8 && newY >= 0 && newY < 8) {
                    const targetPiece = board[newY][newX];
                    
                    // Empty square or capture
                    if (!targetPiece || targetPiece.color !== piece.color) {
                        // Add only if the king wouldn't be in check
                        if (!isSquareAttacked(newX, newY, piece.color === 'white' ? 'black' : 'white')) {
                            moves.push({ x: newX, y: newY });
                        }
                    }
                }
            }
            
            // Castling
            if (piece.color === 'white') {
                // Kingside castling
                if (castlingRights.whiteKingSide) {
                    if (!board[0][5] && !board[0][6] && 
                        !isSquareAttacked(4, 0, 'black') && 
                        !isSquareAttacked(5, 0, 'black') && 
                        !isSquareAttacked(6, 0, 'black')) {
                        moves.push({ x: 6, y: 0, special: 'castle-kingside' });
                    }
                }
                
                // Queenside castling
                if (castlingRights.whiteQueenSide) {
                    if (!board[0][1] && !board[0][2] && !board[0][3] && 
                        !isSquareAttacked(4, 0, 'black') && 
                        !isSquareAttacked(3, 0, 'black') && 
                        !isSquareAttacked(2, 0, 'black')) {
                        moves.push({ x: 2, y: 0, special: 'castle-queenside' });
                    }
                }
            } else {
                // Kingside castling
                if (castlingRights.blackKingSide) {
                    if (!board[7][5] && !board[7][6] && 
                        !isSquareAttacked(4, 7, 'white') && 
                        !isSquareAttacked(5, 7, 'white') && 
                        !isSquareAttacked(6, 7, 'white')) {
                        moves.push({ x: 6, y: 7, special: 'castle-kingside' });
                    }
                }
                
                // Queenside castling
                if (castlingRights.blackQueenSide) {
                    if (!board[7][1] && !board[7][2] && !board[7][3] && 
                        !isSquareAttacked(4, 7, 'white') && 
                        !isSquareAttacked(3, 7, 'white') && 
                        !isSquareAttacked(2, 7, 'white')) {
                        moves.push({ x: 2, y: 7, special: 'castle-queenside' });
                    }
                }
            }
            
            return moves;
        }
        
        // Make a move on the board
        function makeMove(fromX, fromY, toX, toY, special = null) {
            // Stop the clock for the current player
            stopClock();
            
            const piece = board[fromY][fromX];
            if (!piece) return false;
            
            // Record the captured piece if any
            const capturedPiece = board[toY][toX];
            
            // En passant capture
            if (special === 'en-passant') {
                // Remove the pawn that is being captured en passant
                const captureY = piece.color === 'white' ? toY - 1 : toY + 1;
                const capturedPawn = board[captureY][toX];
                board[captureY][toX] = null;
                
                // Add the captured pawn to the captured pieces list
                capturedPieces[piece.color].push(capturedPawn);
            } else if (capturedPiece) {
                // Regular capture
                capturedPieces[piece.color].push(capturedPiece);
            }
            
            // Move the piece
            board[toY][toX] = piece;
            board[fromY][fromX] = null;
            
            // Update en passant target
            if (special === 'double-push') {
                enPassantTarget = { x: toX, y: toY };
            } else {
                enPassantTarget = null;
            }
            
            // Handle castling
            if (special && special.startsWith('castle')) {
                if (special === 'castle-kingside') {
                    // Move the rook for kingside castling
                    const rookY = piece.color === 'white' ? 0 : 7;
                    board[rookY][5] = board[rookY][7]; // Move rook to f1/f8
                    board[rookY][7] = null;            // Remove rook from h1/h8
                } else if (special === 'castle-queenside') {
                    // Move the rook for queenside castling
                    const rookY = piece.color === 'white' ? 0 : 7;
                    board[rookY][3] = board[rookY][0]; // Move rook to d1/d8
                    board[rookY][0] = null;            // Remove rook from a1/a8
                }
            }
            
            // Update castling rights
            updateCastlingRights(fromX, fromY, piece);
            
            // Update king position if a king moved
            if (piece.type === 'king') {
                kingPositions[piece.color] = { x: toX, y: toY };
            }
            
            // Handle promotion
            if (special === 'promotion') {
                pendingPromotion = { x: toX, y: toY, color: piece.color };
                showPromotionDialog(piece.color);
                return true;
            }
            
            // Update board and UI
            renderBoard();
            
            // Record move in history
            recordMove(fromX, fromY, toX, toY, piece, capturedPiece, special);
            
            // Update captured pieces display
            updateCapturedPieces();
            
            // Change turn
            currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
            
            // Start the clock for the next player
            startClock();
            
            // Update game status (check/checkmate/stalemate)
            updateGameStatus();
            
            // Update turn indicators
            updateTurnIndicators();
            
            return true;
        }
        
        // Show promotion dialog
        function showPromotionDialog(color) {
            const promotionPieces = document.getElementById('promotion-pieces');
            promotionPieces.innerHTML = '';
            
            // Add promotion options: queen, rook, bishop, knight
            const pieces = ['queen', 'rook', 'bishop', 'knight'];
            pieces.forEach(pieceType => {
                const pieceElement = document.createElement('div');
                pieceElement.className = 'promotion-piece';
                pieceElement.dataset.type = pieceType;
                
                // Set the unicode character
                if (color === 'white') {
                    switch (pieceType) {
                        case 'queen': pieceElement.textContent = PIECES.WHITE_QUEEN; break;
                        case 'rook': pieceElement.textContent = PIECES.WHITE_ROOK; break;
                        case 'bishop': pieceElement.textContent = PIECES.WHITE_BISHOP; break;
                        case 'knight': pieceElement.textContent = PIECES.WHITE_KNIGHT; break;
                    }
                } else {
                    switch (pieceType) {
                        case 'queen': pieceElement.textContent = PIECES.BLACK_QUEEN; break;
                        case 'rook': pieceElement.textContent = PIECES.BLACK_ROOK; break;
                        case 'bishop': pieceElement.textContent = PIECES.BLACK_BISHOP; break;
                        case 'knight': pieceElement.textContent = PIECES.BLACK_KNIGHT; break;
                    }
                }
                
                // Add click handler
                pieceElement.addEventListener('click', () => {
                    promotePawn(pieceType);
                });
                
                promotionPieces.appendChild(pieceElement);
            });
            
            // Show modal
            showModal('promotion-modal');
        }
        
        // Promote a pawn
        function promotePawn(pieceType) {
            if (!pendingPromotion) return;
            
            // Replace the pawn with the selected piece
            board[pendingPromotion.y][pendingPromotion.x] = {
                type: pieceType,
                color: pendingPromotion.color
            };
            
            // Hide promotion dialog
            hideModal('promotion-modal');
            
            // Update the board
            renderBoard();
            
            // Update the move history with the promotion information
            const lastMove = moveHistory[moveHistory.length - 1];
            lastMove.promotion = pieceType;
            updateMoveHistory();
            
            // Clear pending promotion
            pendingPromotion = null;
            
            // Change turn if it was the user's move
            if (currentPlayer === 'black') {
                currentPlayer = 'white';
                
                // Start the clock for the next player
                startClock();
                
                // Update game status
                updateGameStatus();
                
                // Update turn indicators
                updateTurnIndicators();
                
                // If AI's turn, make AI move
                if (userColor === 'white') {
                    showThinking();
                    setTimeout(() => {
                        makeAIMove();
                        hideThinking();
                    }, 1000);
                }
            } else {
                currentPlayer = 'black';
                
                // Start the clock for the next player
                startClock();
                
                // Update game status
                updateGameStatus();
                
                // Update turn indicators
                updateTurnIndicators();
                
                // If AI's turn, make AI move
                if (userColor === 'black') {
                    showThinking();
                    setTimeout(() => {
                        makeAIMove();
                        hideThinking();
                    }, 1000);
                }
            }
        }
        
        // Update castling rights
        function updateCastlingRights(fromX, fromY, piece) {
            // King move
            if (piece.type === 'king') {
                if (piece.color === 'white') {
                    castlingRights.whiteKingSide = false;
                    castlingRights.whiteQueenSide = false;
                } else {
                    castlingRights.blackKingSide = false;
                    castlingRights.blackQueenSide = false;
                }
            }
            
            // Rook move
            if (piece.type === 'rook') {
                if (piece.color === 'white') {
                    if (fromX === 0 && fromY === 0) { // a1
                        castlingRights.whiteQueenSide = false;
                    } else if (fromX === 7 && fromY === 0) { // h1
                        castlingRights.whiteKingSide = false;
                    }
                } else {
                    if (fromX === 0 && fromY === 7) { // a8
                        castlingRights.blackQueenSide = false;
                    } else if (fromX === 7 && fromY === 7) { // h8
                        castlingRights.blackKingSide = false;
                    }
                }
            }
        }
        
        // Record a move in the history
        function recordMove(fromX, fromY, toX, toY, piece, capturedPiece, special) {
            const from = FILES[fromX] + RANKS[fromY];
            const to = FILES[toX] + RANKS[toY];
            
            const move = {
                from,
                to,
                piece: piece.type,
                color: piece.color,
                captured: capturedPiece ? capturedPiece.type : null,
                special,
                promotion: null, // Will be set if a promotion happens
                san: generateSAN(fromX, fromY, toX, toY, piece, capturedPiece, special)
            };
            
            moveHistory.push(move);
            updateMoveHistory();
        }
        
        // Generate Standard Algebraic Notation (SAN) for a move
        function generateSAN(fromX, fromY, toX, toY, piece, capturedPiece, special) {
            let san = '';
            
            // Special case: castling
            if (special === 'castle-kingside') {
                return 'O-O';
            } else if (special === 'castle-queenside') {
                return 'O-O-O';
            }
            
            // Piece letter (except for pawns)
            if (piece.type !== 'pawn') {
                san += piece.type.charAt(0).toUpperCase();
            }
            
            // Source square disambiguation if needed (for knights, rooks, queens, bishops)
            if (piece.type !== 'pawn' && piece.type !== 'king') {
                let sameTypePieces = [];
                
                // Find all pieces of the same type and color that could move to the target square
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        const otherPiece = board[y][x];
                        if (otherPiece && otherPiece.type === piece.type && otherPiece.color === piece.color &&
                            (x !== fromX || y !== fromY)) {
                            
                            // Check if this piece can move to the target square
                            const validMoves = getValidMoves(x, y);
                            if (validMoves.some(move => move.x === toX && move.y === toY)) {
                                sameTypePieces.push({ x, y });
                            }
                        }
                    }
                }
                
                // Disambiguate if necessary
                if (sameTypePieces.length > 0) {
                    // Try file disambiguation
                    let needFile = sameTypePieces.some(p => p.y === fromY);
                    
                    // Try rank disambiguation
                    let needRank = sameTypePieces.some(p => p.x === fromX);
                    
                    // Add file
                    if (needFile) {
                        san += FILES[fromX];
                    }
                    
                    // Add rank
                    if (needRank && (!needFile || sameTypePieces.some(p => p.x === fromX && p.y !== fromY))) {
                        san += RANKS[fromY];
                    }
                }
            }
            
            // Pawn captures need the file
            if (piece.type === 'pawn' && capturedPiece) {
                san += FILES[fromX];
            }
            
            // Capture indicator
            if (capturedPiece || special === 'en-passant') {
                san += 'x';
            }
            
            // Destination square
            san += FILES[toX] + RANKS[toY];
            
            // Pawn promotion
            if (special === 'promotion') {
                san += '=Q'; // Default to queen, will be updated when the player chooses
            }
            
            // En passant notation
            if (special === 'en-passant') {
                san += ' e.p.';
            }
            
            // Check or checkmate will be added after the move is made
            
            return san;
        }
        
        // Update the move history display
        function updateMoveHistory() {
            const moveList = document.getElementById('move-list').querySelector('tbody');
            moveList.innerHTML = '';
            
            // Group moves by pairs (white and black)
            for (let i = 0; i < moveHistory.length; i += 2) {
                const whiteMove = moveHistory[i];
                const blackMove = moveHistory[i + 1];
                
                const row = document.createElement('tr');
                
                // Move number
                const numberCell = document.createElement('td');
                numberCell.textContent = Math.floor(i / 2) + 1;
                row.appendChild(numberCell);
                
                // White's move
                const whiteCell = document.createElement('td');
                whiteCell.className = 'move-white';
                
                let whiteSan = whiteMove.san;
                if (whiteMove.promotion) {
                    whiteSan = whiteSan.replace('=Q', '=' + whiteMove.promotion.charAt(0).toUpperCase());
                }
                
                // Check if it's a check or checkmate
                if (i + 1 < moveHistory.length) {
                    if (moveHistory[i + 1].special === 'checkmate') {
                        whiteSan += '#';
                    } else if (moveHistory[i + 1].special === 'check') {
                        whiteSan += '+';
                    }
                }
                
                whiteCell.textContent = whiteSan;
                row.appendChild(whiteCell);
                
                // Black's move
                const blackCell = document.createElement('td');
                blackCell.className = 'move-black';
                
                if (blackMove) {
                    let blackSan = blackMove.san;
                    if (blackMove.promotion) {
                        blackSan = blackSan.replace('=Q', '=' + blackMove.promotion.charAt(0).toUpperCase());
                    }
                    
                    // Check if it's a check or checkmate
                    if (i + 2 < moveHistory.length) {
                        if (moveHistory[i + 2].special === 'checkmate') {
                            blackSan += '#';
                        } else if (moveHistory[i + 2].special === 'check') {
                            blackSan += '+';
                        }
                    }
                    
                    blackCell.textContent = blackSan;
                }
                
                row.appendChild(blackCell);
                moveList.appendChild(row);
            }
            
            // Scroll to the bottom
            const moveHistoryEl = document.querySelector('.move-history');
            moveHistoryEl.scrollTop = moveHistoryEl.scrollHeight;
        }
        
        // Update captured pieces display
        function updateCapturedPieces() {
            const capturedByUser = document.getElementById('captured-by-user');
            const capturedByMichel = document.getElementById('captured-by-michel');
            
            capturedByUser.innerHTML = '';
            capturedByMichel.innerHTML = '';
            
            // Display pieces captured by user
            capturedPieces[userColor].forEach(piece => {
                const pieceElement = document.createElement('span');
                pieceElement.className = 'captured-piece';
                pieceElement.textContent = getPieceSymbol(piece);
                capturedByUser.appendChild(pieceElement);
            });
            
            // Display pieces captured by Michel
            capturedPieces[userColor === 'white' ? 'black' : 'white'].forEach(piece => {
                const pieceElement = document.createElement('span');
                pieceElement.className = 'captured-piece';
                pieceElement.textContent = getPieceSymbol(piece);
                capturedByMichel.appendChild(pieceElement);
            });
        }
        
        // Update game status (check, checkmate, stalemate)
        function updateGameStatus() {
            const statusElement = document.getElementById('game-status');
            const kingPos = kingPositions[currentPlayer];
            
            // Remove previous status
            statusElement.classList.remove('check', 'checkmate', 'stalemate');
            
            // Check if the current player's king is in check
            const inCheck = isSquareAttacked(kingPos.x, kingPos.y, currentPlayer === 'white' ? 'black' : 'white');
            
            // Check if the current player has any legal moves
            let hasLegalMoves = false;
            
            outerLoop:
            for (let y = 0; y < 8; y++) {
                for (let x = 0; x < 8; x++) {
                    const piece = board[y][x];
                    if (piece && piece.color === currentPlayer) {
                        const moves = getValidMoves(x, y);
                        if (moves.length > 0) {
                            hasLegalMoves = true;
                            break outerLoop;
                        }
                    }
                }
            }
            
            if (inCheck && !hasLegalMoves) {
                // Checkmate
                gameStatus = 'checkmate';
                statusElement.textContent = `Échec et mat ! ${currentPlayer === 'white' ? 'Les noirs' : 'Les blancs'} gagnent.`;
                statusElement.classList.add('checkmate');
                
                // Stop the clock
                stopClock();
                
                // Add checkmate to the move history
                if (moveHistory.length > 0) {
                    const lastMove = moveHistory[moveHistory.length - 1];
                    lastMove.special = 'checkmate';
                    updateMoveHistory();
                }
            } else if (inCheck) {
                // Check
                gameStatus = 'check';
                statusElement.textContent = `${currentPlayer === 'white' ? 'Les blancs' : 'Les noirs'} sont en échec !`;
                statusElement.classList.add('check');
                
                // Add check to the move history
                if (moveHistory.length > 0) {
                    const lastMove = moveHistory[moveHistory.length - 1];
                    lastMove.special = 'check';
                    updateMoveHistory();
                }
            } else if (!hasLegalMoves) {
                // Stalemate
                gameStatus = 'stalemate';
                statusElement.textContent = `Pat ! La partie est nulle.`;
                statusElement.classList.add('stalemate');
                
                // Stop the clock
                stopClock();
            } else {
                // Game continues
                gameStatus = 'active';
                statusElement.textContent = `Au tour ${currentPlayer === 'white' ? 'des blancs' : 'des noirs'}.`;
            }
            
            // Highlight king if in check
            if (inCheck) {
                const kingSquare = document.querySelector(`.square[data-x="${kingPos.x}"][data-y="${kingPos.y}"]`);
                if (kingSquare) kingSquare.classList.add('check');
            }
        }
        
        // Update turn indicators
        function updateTurnIndicators() {
            const michelTurn = document.getElementById('michel-turn');
            const userTurn = document.getElementById('user-turn');
            
            if (currentPlayer === userColor) {
                michelTurn.style.opacity = '0.2';
                userTurn.style.opacity = '1';
            } else {
                michelTurn.style.opacity = '1';
                userTurn.style.opacity = '0.2';
            }
        }
        
        // AI move function (improved with alpha-beta pruning)
        function makeAIMove() {
            if (gameStatus === 'checkmate' || gameStatus === 'stalemate') {
                return;
            }
            
            // Get the AI's color
            const aiColor = userColor === 'white' ? 'black' : 'white';
            
            if (currentPlayer !== aiColor) {
                return;
            }
            
            // Set depth based on difficulty level
            const depth = difficultyLevel === 1 ? 2 : (difficultyLevel === 2 ? 3 : 4);
            
            // Use minimax with alpha-beta pruning to find the best move
            const bestMove = findBestMove(aiColor, depth);
            
            if (bestMove) {
                // Add move animation
                const pieceElement = document.querySelector(`.square[data-x="${bestMove.fromX}"][data-y="${bestMove.fromY}"] .piece`);
                if (pieceElement) {
                    pieceElement.classList.add('move');
                }
                
                // If there's a piece at the target square, add capture animation
                if (board[bestMove.toY][bestMove.toX]) {
                    const capturedPieceElement = document.querySelector(`.square[data-x="${bestMove.toX}"][data-y="${bestMove.toY}"] .piece`);
                    if (capturedPieceElement) {
                        capturedPieceElement.classList.add('captured');
                    }
                }
                
                // Wait for animation to complete
                setTimeout(() => {
                    // Make the move
                    makeMove(bestMove.fromX, bestMove.fromY, bestMove.toX, bestMove.toY, bestMove.special);
                    
                    // Handle promotion if needed
                    if (pendingPromotion) {
                        // AI always promotes to a queen (best choice in most cases)
                        setTimeout(() => {
                            promotePawn('queen');
                        }, 500);
                    }
                }, 300);
            }
        }
        
        // Find the best move for the AI using minimax with alpha-beta pruning
        function findBestMove(aiColor, depth) {
            // This is a depth-limited minimax search with alpha-beta pruning
            const allPossibleMoves = [];
            
            // Collect all valid moves for the AI
            for (let y = 0; y < 8; y++) {
                for (let x = 0; x < 8; x++) {
                    const piece = board[y][x];
                    if (piece && piece.color === aiColor) {
                        const moves = getValidMoves(x, y);
                        
                        moves.forEach(move => {
                            allPossibleMoves.push({
                                fromX: x,
                                fromY: y,
                                toX: move.x,
                                toY: move.y,
                                special: move.special,
                                piece: piece
                            });
                        });
                    }
                }
            }
            
            if (allPossibleMoves.length === 0) {
                return null;
            }
            
            let bestMove = null;
            let bestScore = -Infinity;
            
            // Evaluate each move
            for (const move of allPossibleMoves) {
                // Make a deep copy of the board
                const boardCopy = JSON.parse(JSON.stringify(board));
                
                // Make the move on the copy
                const capturedPiece = boardCopy[move.toY][move.toX];
                boardCopy[move.toY][move.toX] = boardCopy[move.fromY][move.fromX];
                boardCopy[move.fromY][move.fromX] = null;
                
                // Evaluate the resulting position
                const score = -negamax(boardCopy, depth - 1, -Infinity, Infinity, aiColor === 'white' ? -1 : 1);
                
                // Keep track of the best move
                if (score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                }
            }
            
            return bestMove;
        }
        
        // Negamax with alpha-beta pruning
        function negamax(boardState, depth, alpha, beta, color) {
            if (depth === 0) {
                return evaluatePosition(boardState, color > 0 ? 'white' : 'black');
            }
            
            const playerColor = color > 0 ? 'white' : 'black';
            
            // Check for terminal state
            const isTerminal = isTerminalState(boardState, playerColor);
            if (isTerminal.terminal) {
                if (isTerminal.checkmate) {
                    return color * -10000; // Large negative score for being checkmated
                } else if (isTerminal.stalemate) {
                    return 0; // Draw score for stalemate
                }
            }
            
            let maxScore = -Infinity;
            
            // Generate all possible moves
            for (let y = 0; y < 8; y++) {
                for (let x = 0; x < 8; x++) {
                    const piece = boardState[y][x];
                    if (piece && piece.color === playerColor) {
                        const moves = getValidMovesForBoardState(boardState, x, y, playerColor);
                        
                        for (const move of moves) {
                            // Make a deep copy of the board
                            const newBoardState = JSON.parse(JSON.stringify(boardState));
                            
                            // Make the move
                            newBoardState[move.y][move.x] = newBoardState[y][x];
                            newBoardState[y][x] = null;
                            
                            // Recursive evaluation with negated color
                            const score = -negamax(newBoardState, depth - 1, -beta, -alpha, -color);
                            
                            // Update max score
                            maxScore = Math.max(maxScore, score);
                            
                            // Update alpha
                            alpha = Math.max(alpha, score);
                            
                            // Alpha-beta pruning
                            if (alpha >= beta) {
                                break;
                            }
                        }
                    }
                }
            }
            
            return maxScore;
        }
        
        // Check if the position is a terminal state (checkmate or stalemate)
        function isTerminalState(boardState, playerColor) {
            // Find the king
            let kingX = -1;
            let kingY = -1;
            
            for (let y = 0; y < 8; y++) {
                for (let x = 0; x < 8; x++) {
                    const piece = boardState[y][x];
                    if (piece && piece.type === 'king' && piece.color === playerColor) {
                        kingX = x;
                        kingY = y;
                        break;
                    }
                }
                if (kingX !== -1) break;
            }
            
            // Check if king is in check
            const inCheck = isSquareAttackedInState(boardState, kingX, kingY, playerColor === 'white' ? 'black' : 'white');
            
            // Check if the player has any legal moves
            let hasLegalMoves = false;
            
            outerLoop:
            for (let y = 0; y < 8; y++) {
                for (let x = 0; x < 8; x++) {
                    const piece = boardState[y][x];
                    if (piece && piece.color === playerColor) {
                        const moves = getValidMovesForBoardState(boardState, x, y, playerColor);
                        if (moves.length > 0) {
                            hasLegalMoves = true;
                            break outerLoop;
                        }
                    }
                }
            }
            
            if (!hasLegalMoves) {
                if (inCheck) {
                    return { terminal: true, checkmate: true, stalemate: false };
                } else {
                    return { terminal: true, checkmate: false, stalemate: true };
                }
            }
            
            return { terminal: false, checkmate: false, stalemate: false };
        }
        
        // Check if a square is attacked in a given board state
        function isSquareAttackedInState(boardState, x, y, attackingColor) {
            // Similar to isSquareAttacked, but works on a board state copy
            
            // Pawn attacks
            const pawnDirection = attackingColor === 'white' ? 1 : -1;
            
            // Left diagonal pawn attack
            if (x > 0 && y + pawnDirection >= 0 && y + pawnDirection < 8) {
                const pawn = boardState[y + pawnDirection][x - 1];
                if (pawn && pawn.type === 'pawn' && pawn.color === attackingColor) {
                    return true;
                }
            }
            
            // Right diagonal pawn attack
            if (x < 7 && y + pawnDirection >= 0 && y + pawnDirection < 8) {
                const pawn = boardState[y + pawnDirection][x + 1];
                if (pawn && pawn.type === 'pawn' && pawn.color === attackingColor) {
                    return true;
                }
            }
            
            // Knight attacks
            const knightMoves = [
                { x: x + 2, y: y + 1 }, { x: x + 2, y: y - 1 },
                { x: x - 2, y: y + 1 }, { x: x - 2, y: y - 1 },
                { x: x + 1, y: y + 2 }, { x: x + 1, y: y - 2 },
                { x: x - 1, y: y + 2 }, { x: x - 1, y: y - 2 }
            ];
            
            for (const move of knightMoves) {
                if (move.x >= 0 && move.x < 8 && move.y >= 0 && move.y < 8) {
                    const piece = boardState[move.y][move.x];
                    if (piece && piece.type === 'knight' && piece.color === attackingColor) {
                        return true;
                    }
                }
            }
            
            // King attacks
            const kingMoves = [
                { x: x + 1, y: y }, { x: x - 1, y: y },
                { x: x, y: y + 1 }, { x: x, y: y - 1 },
                { x: x + 1, y: y + 1 }, { x: x + 1, y: y - 1 },
                { x: x - 1, y: y + 1 }, { x: x - 1, y: y - 1 }
            ];
            
            for (const move of kingMoves) {
                if (move.x >= 0 && move.x < 8 && move.y >= 0 && move.y < 8) {
                    const piece = boardState[move.y][move.x];
                    if (piece && piece.type === 'king' && piece.color === attackingColor) {
                        return true;
                    }
                }
            }
            
            // Sliding pieces
            const directions = [
                { dx: 0, dy: 1 },   // up
                { dx: 0, dy: -1 },  // down
                { dx: 1, dy: 0 },   // right
                { dx: -1, dy: 0 },  // left
                { dx: 1, dy: 1 },   // up-right
                { dx: 1, dy: -1 },  // down-right
                { dx: -1, dy: 1 },  // up-left
                { dx: -1, dy: -1 }  // down-left
            ];
            
            for (const dir of directions) {
                let newX = x + dir.dx;
                let newY = y + dir.dy;
                
                while (newX >= 0 && newX < 8 && newY >= 0 && newY < 8) {
                    const piece = boardState[newY][newX];
                    
                    if (piece) {
                        if (piece.color === attackingColor) {
                            // Rook can attack along rank and file
                            if (piece.type === 'rook' && (dir.dx === 0 || dir.dy === 0)) {
                                return true;
                            }
                            
                            // Bishop can attack along diagonals
                            if (piece.type === 'bishop' && dir.dx !== 0 && dir.dy !== 0) {
                                return true;
                            }
                            
                            // Queen can attack in any direction
                            if (piece.type === 'queen') {
                                return true;
                            }
                        }
                        
                        // Stop at any piece
                        break;
                    }
                    
                    newX += dir.dx;
                    newY += dir.dy;
                }
            }
            
            return false;
        }
        
        // Get valid moves for a piece in a given board state
        function getValidMovesForBoardState(boardState, x, y, color) {
            const piece = boardState[y][x];
            if (!piece || piece.color !== color) {
                return [];
            }
            
            // Simplified move generation without considering check
            // (check validation will be done separately)
            let moves = [];
            
            switch (piece.type) {
                case 'pawn':
                    moves = getPawnMovesForState(boardState, x, y);
                    break;
                case 'knight':
                    moves = getKnightMovesForState(boardState, x, y);
                    break;
                case 'bishop':
                    moves = getBishopMovesForState(boardState, x, y);
                    break;
                case 'rook':
                    moves = getRookMovesForState(boardState, x, y);
                    break;
                case 'queen':
                    moves = [...getRookMovesForState(boardState, x, y), ...getBishopMovesForState(boardState, x, y)];
                    break;
                case 'king':
                    moves = getKingMovesForState(boardState, x, y);
                    break;
            }
            
            return moves;
        }
        
        // Simplified pawn moves for board state evaluation
        function getPawnMovesForState(boardState, x, y) {
            const piece = boardState[y][x];
            const moves = [];
            
            const direction = piece.color === 'white' ? 1 : -1;
            
            // Forward move
            if (y + direction >= 0 && y + direction < 8 && !boardState[y + direction][x]) {
                moves.push({ x, y: y + direction });
                
                // Double push from starting rank
                const startRank = piece.color === 'white' ? 1 : 6;
                if (y === startRank && !boardState[y + 2 * direction][x]) {
                    moves.push({ x, y: y + 2 * direction });
                }
            }
            
            // Captures
            for (let dx of [-1, 1]) {
                const newX = x + dx;
                const newY = y + direction;
                
                if (newX >= 0 && newX < 8 && newY >= 0 && newY < 8) {
                    const targetPiece = boardState[newY][newX];
                    if (targetPiece && targetPiece.color !== piece.color) {
                        moves.push({ x: newX, y: newY });
                    }
                }
            }
            
            return moves;
        }
        
        // Simplified knight moves for board state evaluation
        function getKnightMovesForState(boardState, x, y) {
            const piece = boardState[y][x];
            const moves = [];
            
            const offsets = [
                { dx: 2, dy: 1 }, { dx: 2, dy: -1 },
                { dx: -2, dy: 1 }, { dx: -2, dy: -1 },
                { dx: 1, dy: 2 }, { dx: 1, dy: -2 },
                { dx: -1, dy: 2 }, { dx: -1, dy: -2 }
            ];
            
            for (const offset of offsets) {
                const newX = x + offset.dx;
                const newY = y + offset.dy;
                
                if (newX >= 0 && newX < 8 && newY >= 0 && newY < 8) {
                    const targetPiece = boardState[newY][newX];
                    if (!targetPiece || targetPiece.color !== piece.color) {
                        moves.push({ x: newX, y: newY });
                    }
                }
            }
            
            return moves;
        }
        
        // Simplified bishop moves for board state evaluation
        function getBishopMovesForState(boardState, x, y) {
            const piece = boardState[y][x];
            const moves = [];
            
            const directions = [
                { dx: 1, dy: 1 }, { dx: 1, dy: -1 },
                { dx: -1, dy: 1 }, { dx: -1, dy: -1 }
            ];
            
            for (const dir of directions) {
                let newX = x + dir.dx;
                let newY = y + dir.dy;
                
                while (newX >= 0 && newX < 8 && newY >= 0 && newY < 8) {
                    const targetPiece = boardState[newY][newX];
                    
                    if (!targetPiece) {
                        moves.push({ x: newX, y: newY });
                    } else {
                        if (targetPiece.color !== piece.color) {
                            moves.push({ x: newX, y: newY });
                        }
                        break;
                    }
                    
                    newX += dir.dx;
                    newY += dir.dy;
                }
            }
            
            return moves;
        }
        
        // Simplified rook moves for board state evaluation
        function getRookMovesForState(boardState, x, y) {
            const piece = boardState[y][x];
            const moves = [];
            
            const directions = [
                { dx: 0, dy: 1 }, { dx: 0, dy: -1 },
                { dx: 1, dy: 0 }, { dx: -1, dy: 0 }
            ];
            
            for (const dir of directions) {
                let newX = x + dir.dx;
                let newY = y + dir.dy;
                
                while (newX >= 0 && newX < 8 && newY >= 0 && newY < 8) {
                    const targetPiece = boardState[newY][newX];
                    
                    if (!targetPiece) {
                        moves.push({ x: newX, y: newY });
                    } else {
                        if (targetPiece.color !== piece.color) {
                            moves.push({ x: newX, y: newY });
                        }
                        break;
                    }
                    
                    newX += dir.dx;
                    newY += dir.dy;
                }
            }
            
            return moves;
        }
        
        // Simplified king moves for board state evaluation
        function getKingMovesForState(boardState, x, y) {
            const piece = boardState[y][x];
            const moves = [];
            
            const directions = [
                { dx: 0, dy: 1 }, { dx: 0, dy: -1 },
                { dx: 1, dy: 0 }, { dx: -1, dy: 0 },
                { dx: 1, dy: 1 }, { dx: 1, dy: -1 },
                { dx: -1, dy: 1 }, { dx: -1, dy: -1 }
            ];
            
            for (const dir of directions) {
                const newX = x + dir.dx;
                const newY = y + dir.dy;
                
                if (newX >= 0 && newX < 8 && newY >= 0 && newY < 8) {
                    const targetPiece = boardState[newY][newX];
                    if (!targetPiece || targetPiece.color !== piece.color) {
                        moves.push({ x: newX, y: newY });
                    }
                }
            }
            
            return moves;
        }
        
        // Evaluate a position (higher is better for white, lower is better for black)
        function evaluatePosition(boardState, playerColor) {
            let score = 0;
            
            // Material values
            const pieceValues = {
                'pawn': 100,
                'knight': 320,
                'bishop': 330,
                'rook': 500,
                'queen': 900,
                'king': 20000 // Very high value for the king
            };
            
            // Piece-Square Tables (simplified)
            const pawnPositionValue = [
                [0,  0,  0,  0,  0,  0,  0,  0],
                [50, 50, 50, 50, 50, 50, 50, 50],
                [10, 10, 20, 30, 30, 20, 10, 10],
                [5,  5, 10, 25, 25, 10,  5,  5],
                [0,  0,  0, 20, 20,  0,  0,  0],
                [5, -5,-10,  0,  0,-10, -5,  5],
                [5, 10, 10,-20,-20, 10, 10,  5],
                [0,  0,  0,  0,  0,  0,  0,  0]
            ];
            
            const knightPositionValue = [
                [-50,-40,-30,-30,-30,-30,-40,-50],
                [-40,-20,  0,  0,  0,  0,-20,-40],
                [-30,  0, 10, 15, 15, 10,  0,-30],
                [-30,  5, 15, 20, 20, 15,  5,-30],
                [-30,  0, 15, 20, 20, 15,  0,-30],
                [-30,  5, 10, 15, 15, 10,  5,-30],
                [-40,-20,  0,  5,  5,  0,-20,-40],
                [-50,-40,-30,-30,-30,-30,-40,-50]
            ];
            
            const bishopPositionValue = [
                [-20,-10,-10,-10,-10,-10,-10,-20],
                [-10,  0,  0,  0,  0,  0,  0,-10],
                [-10,  0, 10, 10, 10, 10,  0,-10],
                [-10,  5,  5, 10, 10,  5,  5,-10],
                [-10,  0,  5, 10, 10,  5,  0,-10],
                [-10,  5,  5,  5,  5,  5,  5,-10],
                [-10,  0,  5,  0,  0,  5,  0,-10],
                [-20,-10,-10,-10,-10,-10,-10,-20]
            ];
            
            const rookPositionValue = [
                [0,  0,  0,  0,  0,  0,  0,  0],
                [5, 10, 10, 10, 10, 10, 10,  5],
                [-5,  0,  0,  0,  0,  0,  0, -5],
                [-5,  0,  0,  0,  0,  0,  0, -5],
                [-5,  0,  0,  0,  0,  0,  0, -5],
                [-5,  0,  0,  0,  0,  0,  0, -5],
                [-5,  0,  0,  0,  0,  0,  0, -5],
                [0,  0,  0,  5,  5,  0,  0,  0]
            ];
            
            const queenPositionValue = [
                [-20,-10,-10, -5, -5,-10,-10,-20],
                [-10,  0,  0,  0,  0,  0,  0,-10],
                [-10,  0,  5,  5,  5,  5,  0,-10],
                [-5,  0,  5,  5,  5,  5,  0, -5],
                [0,  0,  5,  5,  5,  5,  0, -5],
                [-10,  5,  5,  5,  5,  5,  0,-10],
                [-10,  0,  5,  0,  0,  0,  0,-10],
                [-20,-10,-10, -5, -5,-10,-10,-20]
            ];
            
            const kingMiddleGamePositionValue = [
                [-30,-40,-40,-50,-50,-40,-40,-30],
                [-30,-40,-40,-50,-50,-40,-40,-30],
                [-30,-40,-40,-50,-50,-40,-40,-30],
                [-30,-40,-40,-50,-50,-40,-40,-30],
                [-20,-30,-30,-40,-40,-30,-30,-20],
                [-10,-20,-20,-20,-20,-20,-20,-10],
                [20, 20,  0,  0,  0,  0, 20, 20],
                [20, 30, 10,  0,  0, 10, 30, 20]
            ];
            
            const kingEndGamePositionValue = [
                [-50,-40,-30,-20,-20,-30,-40,-50],
                [-30,-20,-10,  0,  0,-10,-20,-30],
                [-30,-10, 20, 30, 30, 20,-10,-30],
                [-30,-10, 30, 40, 40, 30,-10,-30],
                [-30,-10, 30, 40, 40, 30,-10,-30],
                [-30,-10, 20, 30, 30, 20,-10,-30],
                [-30,-30,  0,  0,  0,  0,-30,-30],
                [-50,-30,-30,-30,-30,-30,-30,-50]
            ];
            
            // Count material and position value
            let whiteMaterial = 0;
            let blackMaterial = 0;
            
            // Check if we are in endgame
            let isEndgame = false;
            let whiteQueenCount = 0;
            let blackQueenCount = 0;
            let whiteRookCount = 0;
            let blackRookCount = 0;
            let whiteMajorPieceCount = 0;
            let blackMajorPieceCount = 0;
            
            // First pass: count material to determine game phase
            for (let y = 0; y < 8; y++) {
                for (let x = 0; x < 8; x++) {
                    const piece = boardState[y][x];
                    if (piece) {
                        if (piece.color === 'white') {
                            whiteMaterial += pieceValues[piece.type];
                            if (piece.type === 'queen') whiteQueenCount++;
                            if (piece.type === 'rook') whiteRookCount++;
                            if (piece.type === 'queen' || piece.type === 'rook' || piece.type === 'bishop' || piece.type === 'knight') {
                                whiteMajorPieceCount++;
                            }
                        } else {
                            blackMaterial += pieceValues[piece.type];
                            if (piece.type === 'queen') blackQueenCount++;
                            if (piece.type === 'rook') blackRookCount++;
                            if (piece.type === 'queen' || piece.type === 'rook' || piece.type === 'bishop' || piece.type === 'knight') {
                                blackMajorPieceCount++;
                            }
                        }
                    }
                }
            }
            
            // Determine if it's endgame
            isEndgame = (whiteQueenCount === 0 && blackQueenCount === 0) || 
                        ((whiteQueenCount === 0 || blackQueenCount === 0) && 
                        (whiteRookCount <= 1 && blackRookCount <= 1) && 
                        (whiteMajorPieceCount <= 2 && blackMajorPieceCount <= 2));
            
            // Second pass: evaluate position
            for (let y = 0; y < 8; y++) {
                for (let x = 0; x < 8; x++) {
                    const piece = boardState[y][x];
                    if (piece) {
                        let positionValue = 0;
                        
                        // Get position value based on piece type and position
                        if (piece.color === 'white') {
                            switch (piece.type) {
                                case 'pawn': 
                                    positionValue = pawnPositionValue[7 - y][x];
                                    break;
                                case 'knight': 
                                    positionValue = knightPositionValue[7 - y][x];
                                    break;
                                case 'bishop': 
                                    positionValue = bishopPositionValue[7 - y][x];
                                    break;
                                case 'rook': 
                                    positionValue = rookPositionValue[7 - y][x];
                                    break;
                                case 'queen': 
                                    positionValue = queenPositionValue[7 - y][x];
                                    break;
                                case 'king': 
                                    positionValue = isEndgame ? 
                                        kingEndGamePositionValue[7 - y][x] : 
                                        kingMiddleGamePositionValue[7 - y][x];
                                    break;
                            }
                            score += pieceValues[piece.type] + positionValue;
                        } else {
                            switch (piece.type) {
                                case 'pawn': 
                                    positionValue = pawnPositionValue[y][x];
                                    break;
                                case 'knight': 
                                    positionValue = knightPositionValue[y][x];
                                    break;
                                case 'bishop': 
                                    positionValue = bishopPositionValue[y][x];
                                    break;
                                case 'rook': 
                                    positionValue = rookPositionValue[y][x];
                                    break;
                                case 'queen': 
                                    positionValue = queenPositionValue[y][x];
                                    break;
                                case 'king': 
                                    positionValue = isEndgame ? 
                                        kingEndGamePositionValue[y][x] : 
                                        kingMiddleGamePositionValue[y][x];
                                    break;
                            }
                            score -= (pieceValues[piece.type] + positionValue);
                        }
                        
                        // Additional factors for specific pieces
                        if (piece.type === 'pawn') {
                            // Bonus for passed pawns
                            if (isPawnPassed(boardState, x, y, piece.color)) {
                                score += piece.color === 'white' ? 50 : -50;
                            }
                            
                            // Penalty for doubled pawns
                            if (isDoubledPawn(boardState, x, y, piece.color)) {
                                score += piece.color === 'white' ? -10 : 10;
                            }
                            
                            // Bonus for connected pawns
                            if (isConnectedPawn(boardState, x, y, piece.color)) {
                                score += piece.color === 'white' ? 10 : -10;
                            }
                        }
                        
                        // Mobility bonus (more moves = better)
                        const moves = getValidMovesForBoardState(boardState, x, y, piece.color);
                        score += piece.color === 'white' ? moves.length * 5 : -moves.length * 5;
                        
                        // King safety
                        if (piece.type === 'king') {
                            const pawnShieldBonus = evaluatePawnShield(boardState, x, y, piece.color);
                            score += piece.color === 'white' ? pawnShieldBonus : -pawnShieldBonus;
                        }
                    }
                }
            }
            
            // King safety (check threats against king)
            const whiteKingPos = findKingPosition(boardState, 'white');
            const blackKingPos = findKingPosition(boardState, 'black');
            
            if (whiteKingPos) {
                const whiteKingSafety = evaluateKingSafety(boardState, whiteKingPos.x, whiteKingPos.y, 'white');
                score += whiteKingSafety;
            }
            
            if (blackKingPos) {
                const blackKingSafety = evaluateKingSafety(boardState, blackKingPos.x, blackKingPos.y, 'black');
                score -= blackKingSafety;
            }
            
            // Center control
            score += evaluateCenterControl(boardState, 'white');
            score -= evaluateCenterControl(boardState, 'black');
            
            // Adjust score based on current player
            return playerColor === 'white' ? score : -score;
        }
        
        // Find the king position in a board state
        function findKingPosition(boardState, color) {
            for (let y = 0; y < 8; y++) {
                for (let x = 0; x < 8; x++) {
                    const piece = boardState[y][x];
                    if (piece && piece.type === 'king' && piece.color === color) {
                        return { x, y };
                    }
                }
            }
            return null;
        }
        
        // Evaluate pawn shield around king
        function evaluatePawnShield(boardState, kingX, kingY, kingColor) {
            let bonus = 0;
            const direction = kingColor === 'white' ? 1 : -1;
            
            // Check for pawns in front of the king
            for (let dx = -1; dx <= 1; dx++) {
                const x = kingX + dx;
                if (x >= 0 && x < 8) {
                    for (let step = 1; step <= 2; step++) {
                        const y = kingY + step * direction;
                        if (y >= 0 && y < 8) {
                            const piece = boardState[y][x];
                            if (piece && piece.type === 'pawn' && piece.color === kingColor) {
                                bonus += (3 - step) * 10; // Closer pawns are better
                                break;
                            }
                        }
                    }
                }
            }
            
            return bonus;
        }
        
        // Evaluate king safety
        function evaluateKingSafety(boardState, kingX, kingY, kingColor) {
            let safety = 0;
            const enemyColor = kingColor === 'white' ? 'black' : 'white';
            
            // Check if king is in check
            if (isSquareAttackedInState(boardState, kingX, kingY, enemyColor)) {
                safety -= 50;
            }
            
            // Count number of enemy pieces that can attack squares around the king
            const kingMoves = [
                { x: kingX + 1, y: kingY },
                { x: kingX - 1, y: kingY },
                { x: kingX, y: kingY + 1 },
                { x: kingX, y: kingY - 1 },
                { x: kingX + 1, y: kingY + 1 },
                { x: kingX + 1, y: kingY - 1 },
                { x: kingX - 1, y: kingY + 1 },
                { x: kingX - 1, y: kingY - 1 }
            ];
            
            let attackedSquares = 0;
            for (const move of kingMoves) {
                if (move.x >= 0 && move.x < 8 && move.y >= 0 && move.y < 8) {
                    if (isSquareAttackedInState(boardState, move.x, move.y, enemyColor)) {
                        attackedSquares++;
                    }
                }
            }
            
            safety -= attackedSquares * 10;
            
            return safety;
        }
        
        // Evaluate center control
        function evaluateCenterControl(boardState, color) {
            let centerControl = 0;
            const centerSquares = [
                { x: 3, y: 3 }, { x: 3, y: 4 },
                { x: 4, y: 3 }, { x: 4, y: 4 }
            ];
            
            for (const square of centerSquares) {
                const piece = boardState[square.y][square.x];
                if (piece && piece.color === color) {
                    centerControl += 10;
                }
                
                // Add points for each piece that attacks center squares
                if (isSquareAttackedInState(boardState, square.x, square.y, color)) {
                    centerControl += 5;
                }
            }
            
            return centerControl;
        }
        
        // Check if a pawn is passed (no enemy pawns ahead of it)
        function isPawnPassed(boardState, x, y, color) {
            const direction = color === 'white' ? 1 : -1;
            const enemyColor = color === 'white' ? 'black' : 'white';
            
            // Check all squares in front of the pawn
            for (let newY = y + direction; newY >= 0 && newY < 8; newY += direction) {
                // Check three files (the pawn's file and adjacent files)
                for (let dx = -1; dx <= 1; dx++) {
                    const newX = x + dx;
                    if (newX >= 0 && newX < 8) {
                        const piece = boardState[newY][newX];
                        if (piece && piece.type === 'pawn' && piece.color === enemyColor) {
                            return false;
                        }
                    }
                }
            }
            
            return true;
        }
        
        // Check if a pawn is doubled (another pawn of same color on same file)
        function isDoubledPawn(boardState, x, y, color) {
            for (let newY = 0; newY < 8; newY++) {
                if (newY !== y) {
                    const piece = boardState[newY][x];
                    if (piece && piece.type === 'pawn' && piece.color === color) {
                        return true;
                    }
                }
            }
            return false;
        }
        
        // Check if a pawn is connected (protected by another pawn)
        function isConnectedPawn(boardState, x, y, color) {
            for (let dx = -1; dx <= 1; dx += 2) {
                const newX = x + dx;
                if (newX >= 0 && newX < 8) {
                    const piece = boardState[y][newX];
                    if (piece && piece.type === 'pawn' && piece.color === color) {
                        return true;
                    }
                }
            }
            return false;
        }
        
        // Set up event listeners
        document.getElementById('play-white').addEventListener('click', function() {
            userColor = 'white';
            document.getElementById('play-white').className = 'btn btn-primary';
            document.getElementById('play-black').className = 'btn btn-outline';
            initializeBoard();
            updateTurnIndicators();
            showToast('Vous jouez les blancs', 'toast-success');
        });
        
        document.getElementById('play-black').addEventListener('click', function() {
            userColor = 'black';
            document.getElementById('play-black').className = 'btn btn-primary';
            document.getElementById('play-white').className = 'btn btn-outline';
            initializeBoard();
            updateTurnIndicators();
            showToast('Vous jouez les noirs', 'toast-success');
        });
        
        document.getElementById('reset-btn').addEventListener('click', function() {
            showModal('new-game-modal');
        });
        
        document.getElementById('confirm-new-game').addEventListener('click', function() {
            initializeBoard();
            hideModal('new-game-modal');
            showToast('Nouvelle partie commencée', 'toast-success');
        });
        
        document.getElementById('cancel-new-game').addEventListener('click', function() {
            hideModal('new-game-modal');
        });
        
        document.querySelectorAll('.modal-close').forEach(btn => {
            btn.addEventListener('click', function() {
                const modal = this.closest('.modal-overlay');
                hideModal(modal.id);
            });
        });
        
        document.getElementById('undo-btn').addEventListener('click', function() {
            // Not implemented in this version
            showToast("La fonction d'annulation n'est pas disponible dans cette version", 'toast-warning');
        });
        
        document.getElementById('hint-btn').addEventListener('click', function() {
            showLoading();
            
            // Find a good move for the user
            if (currentPlayer === userColor && gameStatus === 'active') {
                const depth = difficultyLevel;
                const bestMove = findBestMove(userColor, depth);
                
                if (bestMove) {
                    // Highlight the suggested move
                    const fromSquare = document.querySelector(`.square[data-x="${bestMove.fromX}"][data-y="${bestMove.fromY}"]`);
                    const toSquare = document.querySelector(`.square[data-x="${bestMove.toX}"][data-y="${bestMove.toY}"]`);
                    
                    if (fromSquare && toSquare) {
                        fromSquare.classList.add('highlight');
                        toSquare.classList.add('highlight');
                        
                        // Remove highlight after 3 seconds
                        setTimeout(() => {
                            fromSquare.classList.remove('highlight');
                            toSquare.classList.remove('highlight');
                        }, 3000);
                        
                        showToast(`Conseil: déplacez ${getPieceSymbol(bestMove.piece)} de ${FILES[bestMove.fromX]}${RANKS[bestMove.fromY]} à ${FILES[bestMove.toX]}${RANKS[bestMove.toY]}`, 'toast-success');
                    }
                } else {
                    showToast("Pas de conseils disponibles", 'toast-warning');
                }
            } else {
                showToast("Les conseils ne sont disponibles que pendant votre tour", 'toast-warning');
            }
        });
        
        document.getElementById('copy-pgn').addEventListener('click', function() {
            // Generate PGN notation from move history
            let pgn = '';
            
            // Add headers
            pgn += '[Event "Partie en ligne vs Michel"]\n';
            pgn += `[Date "${new Date().toISOString().split('T')[0]}"]\n`;
            pgn += '[White "' + (userColor === 'white' ? 'Utilisateur' : 'Michel') + '"]\n';
            pgn += '[Black "' + (userColor === 'black' ? 'Utilisateur' : 'Michel') + '"]\n';
            pgn += '[Result "*"]\n\n';
            
            // Add moves
            for (let i = 0; i < moveHistory.length; i++) {
                const move = moveHistory[i];
                
                if (i % 2 === 0) {
                    pgn += `${Math.floor(i / 2) + 1}. `;
                }
                
                let san = move.san;
                if (move.promotion) {
                    san = san.replace('=Q', '=' + move.promotion.charAt(0).toUpperCase());
                }
                
                if (move.special === 'check') {
                    san += '+';
                } else if (move.special === 'checkmate') {
                    san += '#';
                }
                
                pgn += san + ' ';
                
                // Line break every 5 moves
                if (i % 10 === 9) {
                    pgn += '\n';
                }
            }
            
            // Copy to clipboard
            navigator.clipboard.writeText(pgn.trim())
                .then(() => {
                    showToast('PGN copié dans le presse-papiers', 'toast-success');
                })
                .catch(() => {
                    showToast('Impossible de copier le PGN', 'toast-warning');
                });
        });
        
        // Flip board button
        document.getElementById('flip-btn').addEventListener('click', function() {
            boardFlipped = !boardFlipped;
            const chessboard = document.getElementById('chessboard');
            
            if (boardFlipped) {
                chessboard.classList.add('flipped');
            } else {
                chessboard.classList.remove('flipped');
            }
            
            renderBoard();
            showToast(`Échiquier ${boardFlipped ? 'retourné' : 'normal'}`);
        });
        
        // Difficulty selection
        document.querySelectorAll('.difficulty-option').forEach(option => {
            option.addEventListener('click', function() {
                document.querySelectorAll('.difficulty-option').forEach(opt => {
                    opt.classList.remove('selected');
                });
                this.classList.add('selected');
                difficultyLevel = parseInt(this.dataset.level);
                showToast(`Difficulté définie sur: ${difficultyLevel === 1 ? 'Facile' : (difficultyLevel === 2 ? 'Moyen' : 'Difficile')}`, 'toast-success');
            });
        });
        
        // Initialize the board when the page loads
        initializeBoard();
    </script>
</body>
</html>